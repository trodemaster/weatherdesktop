package main

import (
	"flag"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"time"

	"github.com/trodemaster/weatherdesktop/pkg/assets"
	"github.com/trodemaster/weatherdesktop/pkg/desktop"
	"github.com/trodemaster/weatherdesktop/pkg/docker"
)

var (
	scrapeFlag      = flag.Bool("s", false, "Scrape websites")
	downloadFlag    = flag.Bool("d", false, "Download images")
	cropFlag        = flag.Bool("c", false, "Crop/resize images")
	renderFlag      = flag.Bool("r", false, "Render composite image")
	desktopFlag     = flag.Bool("p", false, "Set desktop wallpaper")
	desktopImageFlag = flag.String("set-desktop", "", "Set desktop wallpaper from specified image file path")
	flushFlag       = flag.Bool("f", false, "Flush/clear assets directory")
	debugFlag       = flag.Bool("debug", false, "Enable debug output")
	scrapeTargetFlag = flag.String("scrape-target", "", "Test specific scrape target by name")
	listTargetsFlag = flag.Bool("list-targets", false, "List all available scrape targets and exit")
)

func main() {
	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "USAGE: wd [options]\n\n")
		fmt.Fprintf(os.Stderr, "Running wd without options will collect all assets,\n")
		fmt.Fprintf(os.Stderr, "render and set the desktop image to the output.\n\n")
		fmt.Fprintf(os.Stderr, "Individual options provided for debugging specific functions.\n\n")
		fmt.Fprintf(os.Stderr, "PHASE OPTIONS:\n")
		fmt.Fprintf(os.Stderr, "   -s                    Scrape Sites\n")
		fmt.Fprintf(os.Stderr, "   -d                    Download Images\n")
		fmt.Fprintf(os.Stderr, "   -c                    Crop Images\n")
		fmt.Fprintf(os.Stderr, "   -r                    Render Image\n")
		fmt.Fprintf(os.Stderr, "   -p                    Set Desktop (uses most recent rendered image)\n")
		fmt.Fprintf(os.Stderr, "   -set-desktop <path>   Set desktop wallpaper from specified image file\n")
		fmt.Fprintf(os.Stderr, "   -f                    Flush assets\n")
		fmt.Fprintf(os.Stderr, "\nDEBUG OPTIONS:\n")
		fmt.Fprintf(os.Stderr, "   -debug                Enable debug output\n")
		fmt.Fprintf(os.Stderr, "   -list-targets         List all available scrape targets\n")
		fmt.Fprintf(os.Stderr, "   -scrape-target <name> Test specific scrape target (e.g., \"Weather.gov Hourly\")\n")
		fmt.Fprintf(os.Stderr, "\nEXAMPLES:\n")
		fmt.Fprintf(os.Stderr, "   wd -s -scrape-target \"NWAC Stevens\" -debug\n")
		fmt.Fprintf(os.Stderr, "   wd -s -debug\n")
		fmt.Fprintf(os.Stderr, "   wd -set-desktop ./rendered/hud-251102-1056.jpg\n")
	}
	
	flag.Parse()

	// Handle list-targets flag (special case - exits after listing)
	if *listTargetsFlag {
		listScrapeTargets()
		return
	}

	// Handle set-desktop flag (special case - just set desktop from specified file)
	// Always allows desktop setting (even with -debug) since it's explicitly requested
	if *desktopImageFlag != "" {
		imagePath := *desktopImageFlag
		
		// Resolve to absolute path if relative
		if !filepath.IsAbs(imagePath) {
			wd, err := os.Getwd()
			if err != nil {
				log.Fatalf("Failed to get working directory: %v", err)
			}
			imagePath = filepath.Join(wd, imagePath)
		}
		
		// Normalize the path
		absPath, err := filepath.Abs(imagePath)
		if err != nil {
			log.Fatalf("Failed to resolve image path: %v", err)
		}
		
		if *debugFlag {
			log.Printf("Setting desktop wallpaper on all screens (debug mode) from: %s", absPath)
		} else {
			log.Printf("Setting desktop wallpaper on all screens from: %s", absPath)
		}
		if err := setDesktopWallpaper(absPath); err != nil {
			log.Fatalf("Failed to set desktop: %v", err)
		}
		log.Println("✓ Desktop wallpaper set successfully on all screens")
		return
	}

	// Get script directory
	scriptDir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		log.Fatalf("Failed to get script directory: %v", err)
	}

	// Initialize Docker client
	dockerClient := docker.New(scriptDir)

	// Determine which phases to run
	// If no flags set, run all phases (same logic as bash script lines 82-84)
	// Note: desktopImageFlag is handled separately above, so we exclude it from runAll check
	runAll := !(*scrapeFlag || *downloadFlag || *cropFlag || *renderFlag || *desktopFlag || *flushFlag)
	
	doScrape := runAll || *scrapeFlag
	doDownload := runAll || *downloadFlag
	doCrop := runAll || *cropFlag
	doRender := runAll || *renderFlag
	doDesktop := runAll || *desktopFlag
	doFlush := runAll || *flushFlag
	
	// Filename will be generated by container at render time to avoid timezone/timing issues
	log.Printf("Starting wallpaper generation...")

	// Phase 0: Flush assets if requested
	if doFlush {
		if err := flushAssets(scriptDir); err != nil {
			log.Printf("Warning: Failed to flush assets: %v", err)
		}
	}

	// Ensure Docker container is running for any Docker-based phases
	if doDownload || doScrape || doCrop || doRender {
		if err := dockerClient.EnsureRunning(); err != nil {
			log.Fatalf("Failed to ensure Docker container is running: %v", err)
		}
	}

	// Phase 1: Scrape websites
	if doScrape {
		log.Println("Scraping sites...")
		
		args := []string{"/app/wd-worker", "scrape"}
		if *debugFlag {
			args = append(args, "--debug")
		}
		if *scrapeTargetFlag != "" {
			args = append(args, "--target", *scrapeTargetFlag)
		}
		
		if err := dockerClient.Exec(args...); err != nil {
			log.Fatalf("Failed to scrape sites: %v", err)
		}
	}

	// Phase 2: Download images
	if doDownload {
		log.Println("Downloading images...")
		
		if err := dockerClient.Exec("/app/wd-worker", "download"); err != nil {
			log.Fatalf("Failed to download images: %v", err)
		}
	}

	// Wait for asset collection to complete
	if doDownload || doScrape {
		log.Println("Asset Collection Completed...")
	}

	// Phase 3: Crop and resize images
	if doCrop {
		log.Println("Cropping images...")
		
		if err := dockerClient.Exec("/app/wd-worker", "crop"); err != nil {
			log.Fatalf("Failed to crop images: %v", err)
		}
		
		log.Println("Cropping completed...")
	}

	// Phase 4: Render composite image
	if doRender {
		log.Println("Rendering...")
		
		if err := dockerClient.Exec("/app/wd-worker", "render"); err != nil {
			log.Fatalf("Failed to render composite: %v", err)
		}
		
		log.Println("Rendering completed...")
	}

	// Phase 5: Set desktop wallpaper
	if doDesktop {
		// Skip desktop setting in debug mode UNLESS desktop was explicitly requested (-p flag)
		// This allows troubleshooting desktop setting with -p -debug while preventing accidental
		// wallpaper changes during other debug operations
		skipDesktopInDebug := *debugFlag && !*desktopFlag
		if skipDesktopInDebug {
			log.Println("⚠️  Skipping desktop wallpaper setting (debug mode active)")
			log.Println("   Use -p -debug to set desktop with debug output, or remove -debug flag")
		} else {
			// Find the most recent rendered file
			renderedDir := filepath.Join(scriptDir, "rendered")
			renderedPath, err := findMostRecentRendered(renderedDir)
			if err != nil {
				log.Fatalf("Failed to find rendered file: %v", err)
			}
			
			if *debugFlag {
				log.Printf("Setting desktop wallpaper on all screens (debug mode): %s", renderedPath)
			} else {
				log.Printf("Setting desktop wallpaper on all screens: %s", renderedPath)
			}
			if err := setDesktopWallpaper(renderedPath); err != nil {
				log.Fatalf("Failed to set desktop: %v", err)
			}
			log.Println("✓ Desktop wallpaper set successfully on all screens")
		}
	} else {
		log.Printf("Skipping desktop wallpaper (doDesktop=%v, runAll=%v, desktopFlag=%v)", doDesktop, runAll, *desktopFlag)
	}

	// Optional: Copy to CDN if mounted
	cdnPath := "/Volumes/Bomb20/cdn"
	if doRender {
		if info, err := os.Stat(cdnPath); err == nil && info.IsDir() {
			renderedDir := filepath.Join(scriptDir, "rendered")
			renderedPath, err := findMostRecentRendered(renderedDir)
			if err == nil {
				destPath := filepath.Join(cdnPath, "stevens_pass.jpg")
				log.Printf("Copying %s to %s", renderedPath, destPath)
				if err := copyFile(renderedPath, destPath); err != nil {
					log.Printf("Warning: Failed to copy to CDN: %v", err)
				}
			}
		}
	}

	log.Println("End of Line...")
}

// flushAssets removes all files from the assets directory
func findMostRecentRendered(renderedDir string) (string, error) {
	pattern := filepath.Join(renderedDir, "hud-*.jpg")
	files, err := filepath.Glob(pattern)
	if err != nil {
		return "", fmt.Errorf("failed to glob rendered files: %w", err)
	}
	
	if len(files) == 0 {
		return "", fmt.Errorf("no rendered files found in %s", renderedDir)
	}
	
	// Find the most recently modified file
	var mostRecent string
	var mostRecentTime time.Time
	
	for _, file := range files {
		info, err := os.Stat(file)
		if err != nil {
			continue
		}
		
		if mostRecent == "" || info.ModTime().After(mostRecentTime) {
			mostRecent = file
			mostRecentTime = info.ModTime()
		}
	}
	
	if mostRecent == "" {
		return "", fmt.Errorf("failed to determine most recent rendered file")
	}
	
	return mostRecent, nil
}

func flushAssets(scriptDir string) error {
	assetsDir := filepath.Join(scriptDir, "assets")
	
	// Read directory
	files, err := os.ReadDir(assetsDir)
	if err != nil {
		return fmt.Errorf("failed to read assets directory: %w", err)
	}
	
	// Remove each file
	for _, file := range files {
		if !file.IsDir() {
			filePath := filepath.Join(assetsDir, file.Name())
			log.Printf("Removing %s", filePath)
			if err := os.Remove(filePath); err != nil {
				log.Printf("Warning: Failed to remove %s: %v", filePath, err)
			}
		}
	}
	
	return nil
}

// setDesktopWallpaper sets the desktop wallpaper using CGO
func setDesktopWallpaper(imagePath string) error {
	verbose := *debugFlag
	log.Printf("Desktop: ========================================")
	log.Printf("Desktop: Setting desktop wallpaper")
	log.Printf("Desktop: Image path: %s", imagePath)
	log.Printf("Desktop: Verbose logging: %v", verbose)
	log.Printf("Desktop: ========================================")
	
	if err := desktop.SetWallpaper(imagePath, verbose); err != nil {
		log.Printf("Desktop: ERROR - SetWallpaper failed: %v", err)
		return err
	}
	log.Printf("Desktop: SetWallpaper completed successfully")
	
	// Also clear wallpaper cache
	log.Printf("Desktop: Clearing wallpaper cache...")
	if err := desktop.ClearWallpaperCache(verbose); err != nil {
		log.Printf("Desktop: Warning: %v", err)
	}
	
	log.Printf("Desktop: ========================================")
	log.Printf("Desktop: Desktop wallpaper setting process complete")
	log.Printf("Desktop: ========================================")
	
	return nil
}

func copyFile(src, dst string) error {
	input, err := os.ReadFile(src)
	if err != nil {
		return err
	}
	return os.WriteFile(dst, input, 0644)
}

// listScrapeTargets lists all available scrape targets
func listScrapeTargets() {
	// Get current directory to create manager
	scriptDir, err := filepath.Abs(filepath.Dir(os.Args[0]))
	if err != nil {
		scriptDir = "."
	}
	
	mgr := assets.NewManager(scriptDir)
	targets := mgr.GetScrapeTargets()
	
	fmt.Println("Available Scrape Targets:")
	fmt.Println()
	
	for i, target := range targets {
		fmt.Printf("%d. %s\n", i+1, target.Name)
		fmt.Printf("   URL: %s\n", target.URL)
		fmt.Printf("   Selector: %s\n", target.Selector)
		fmt.Printf("   Default Wait: %dms\n", target.WaitTime)
		fmt.Printf("   Output: %s\n", filepath.Base(target.OutputPath))
		fmt.Println()
	}
	
	htmlTarget := mgr.GetWSDOTHTMLTarget()
	fmt.Printf("HTML Extraction Target:\n")
	fmt.Printf("   %s\n", htmlTarget.Name)
	fmt.Printf("   URL: %s\n", htmlTarget.URL)
	fmt.Printf("   Output: %s\n", filepath.Base(htmlTarget.OutputPath))
	fmt.Println()
	
	fmt.Println("Usage:")
	fmt.Println("  wd -s -scrape-target \"<name>\" -debug")
	fmt.Println()
	fmt.Println("Examples:")
	fmt.Println("  wd -s -scrape-target \"Weather.gov Hourly\" -debug")
	fmt.Println("  wd -s -scrape-target \"NWAC\" -debug     # Matches all NWAC targets")
}

